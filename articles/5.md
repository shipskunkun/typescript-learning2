### 2  ts 区别

静态类型语言：在编译阶段确定所有变量类型

动态类型语言：在执行阶段确定所有变量类型



强类型语言：不允许改变变量的数据类型，除非进行强制类型转换

弱类型语言：变量可以被赋予不同的数据类型



### 3 初始化过程：

```
npm init -y     // package.json

npm i typescript  -g   //全局安装ts

tsc --init    //tscconfig.json
```



可以借助 ts playground 看，编译后的js 代码



使用webpack 构建

```
cnpm i webpack webpack-cli webpack-dev-server -D

//安装ts-loader 本地ts

npm its-loader typescript -D

// 通过模板文件，生成网站首页，并嵌入输出文件
npm i html-webpack-plugin -D
```

创建 build 文件夹

放入4个 js 文件

```
base、config、dev、pro
```

cheap 忽略信息，module 定位到ts源码，而不是ts-loader转译后的js源码

devtool: 'cheap-module-eval-source-map'



生产环境：

```
npm i clean-webpack-plugin -D 
```



安装merge, 配置 config 文件

```
npm i webpack-merge -D
```





### 5  基本类型

联合类型

```
let num: number | undefined = 123
```

nerver: 永远不会有返回值的类型

void : 一个函数没有返回值



###  枚举类型

一组有名字的常量集合，类别手机通讯录，不能被修改



数字枚举，可递增



### 7、8 接口

当接口定义了两个参数，但是后端返回3个参数，预定之外的字段，会报错么？不会

只要满足接口的必要条件，就可以通过检查





什么是类型断言？

sth as  



当不确定接口属性个数的时候，可索引类型的接口

定义用数字索引的接口：

```js
interface StringArray {
    [index: number]: string
}

let chars: StringArray = ['a', 'b']
```



定义函数的几种方式

```js
let add: (x: number, y: number) => number
 interface Add {
     (x: number, y: number): number
 }
type Add = (x: number, y: number) => number
```

混合类型接口

既可以定义函数、也定义了属性、还有方法

```
interface Lib {
    (): void;
    version: string;
    doSomething(): void;
}
```



### 9函数重载

ts 的函数重载，要求我们先定义一系列的，名称相同的函数声明

然后，在类型最宽泛的版本中，实现我们的重载

```js
function add8(...rest: number[]): number;
function add8(...rest: string[]): string;
function add8(...rest: any[]) {
    let first = rest[0];
    if (typeof first === 'number') {
        return rest.reduce((pre, cur) => pre + cur);
    }
    if (typeof first === 'string') {
        return rest.join('');
    }
}
console.log(add8(1, 2))
console.log(add8('a', 'b', 'c'))

```



### 10 类

与es6 中比较，ts 中的类，构造函数，成员属性添加了类型标注

子类继承父类，在constructor中，调用super ，之后，才能使用 this

属性修饰符

静态成员，只能通过类名调用，不能通过子类调用



### 11抽象类

es 中没有抽象类？？

只能被继承，而不能被实例化的类



链式调用,

父类子类之间调用的连贯性

```js
class Workflow {
    step1() {
        return this
    }
    step2() {
        return this
    }
}
new Workflow().step1().step2()

class MyFlow extends Workflow {
    next() {
        return this
    }
}
new MyFlow().next().step1().next().step2()


```



### 12  用接口定义类

定义类的属性、方法

```js
interface Human {
    name: string;
    eat(): void;
}

```

接口的多继承

```js
interface Boy extends Man, Child {}
```



接口可以定义类，接口也可以继承类，



### 13  14泛型

为什么用any替代不了 泛型，忽略了输入参数和函数返回值 之间的关系，必须一致

不能预先定义的类型，具体的类型，需要再使用的时候才能确定



1. 使用泛型定义函数：

在函数的名称之后，<T> ， 参数加上 T ， 返回加上 T

2. 使用泛型定义 type

3. 使用泛型定义 接口

4. 泛型定义类

不能用于类的静态成员



什么是泛型约束

使用接口预定义，然后让 T继承接口



```
interface Length {
    length: number
}
function logAdvance<T extends Length>(value: T): T {
    console.log(value, value.length);
    return value;
}
```



### 15 类型检查机制

1. 类型推断

   不需要指定变量的类型，可以根据某些规则自动的推导出一个类型

   发生时机：

   1. 从右到左

   + 变量定义
   + 函数参数赋值
   + 确认函数返回值的时候

   2. 从左到右

   + 事件绑定，window.onkeydown



类型断言：

sth  as  **



1. 类型兼容性
2. 类型保护





### 16类型兼容性

1. 变量兼容性

父类可以赋值给子类，但是子类型由于缺少父类型的部分属性，不能给父类型赋值

兼容性，经常发生在，变量之间赋值

```
let x: X = {a: 1, b: 2}
let y: Y = {a: 1, b: 2, c: 3}
x = y
// y = x
```

源类型，必须具备，目标类型的必要属性



2. 函数兼容性

   